import { createElement } from '@syncfusion/ej2-base';
import { measureText, RectOption, TextOption, renderTextElement } from '../../smithchart/utils/helper';
import { getTemplateFunction, convertElementFromLabel, PathOption } from '../../smithchart/utils/helper';
import { Rect, LabelPosition, DataLabelTextOptions, LabelOption } from '../../smithchart/utils/utils';
var DataLabel = (function () {
    function DataLabel() {
        this.textOptions = [];
        this.labelOptions = [];
        this.allPoints = [];
    }
    DataLabel.prototype.drawDataLabel = function (smithchart, seriesindex, groupElement, pointsRegion, bounds) {
        this.textOptions = [];
        this.allPoints = [];
        if (smithchart.series[seriesindex].marker.dataLabel.visible) {
            var gdEle = smithchart.renderer.createGroup({ 'id': smithchart.element.id + '_svg'
                    + '_series' + seriesindex + '_Datalabel' });
            groupElement.appendChild(gdEle);
            var margin = smithchart.margin;
            var pointIndex = void 0;
            var marker = smithchart.series[seriesindex];
            var region = void 0;
            var labelPosition = void 0;
            var labelText = void 0;
            var textSize = void 0;
            var dataLabel = void 0;
            var markerSize = void 0;
            var font = smithchart.font;
            var labelElement = void 0;
            var count = pointsRegion.length;
            for (var i = 0; i < count; i++) {
                dataLabel = smithchart.series[seriesindex].marker.dataLabel;
                marker = smithchart.series[seriesindex].marker;
                labelText = smithchart.series[seriesindex].points[i].reactance.toString();
                textSize = measureText(labelText, font);
                markerSize = marker.size;
                region = pointsRegion[i]['point'];
                var xPos = region.x - textSize.width / 2;
                var yPos = region.y - (textSize.height + markerSize['height'] + (margin.top));
                var width = textSize.width + (margin.left / 2) + (margin.right / 2);
                var height = textSize.height + (margin.top / 2) + (margin.bottom / 2);
                pointIndex = i;
                labelPosition = new LabelPosition();
                labelPosition = { textX: xPos + (margin.left / 2), textY: yPos + (height / 2) + margin.top / 2, x: xPos, y: yPos };
                this.textOptions.push({
                    id: smithchart.element.id + '_Series' + seriesindex + '_Points' + pointIndex + '_dataLabel' + '_displayText' + i,
                    x: labelPosition['textX'],
                    y: labelPosition['textY'],
                    fill: 'black',
                    text: labelText,
                    font: font,
                    xPosition: xPos,
                    yPosition: yPos,
                    width: width,
                    height: height,
                    location: region,
                    labelOptions: labelPosition,
                    visible: true,
                    connectorFlag: null
                });
            }
            var labelOption = new LabelOption();
            labelOption.textOptions = this.textOptions;
            this.labelOptions.push(labelOption);
            this.drawDatalabelSymbol(smithchart, seriesindex, dataLabel, groupElement, gdEle, bounds);
        }
    };
    DataLabel.prototype.calculateSmartLabels = function (points, seriesIndex) {
        var length = points['textOptions'].length;
        var count = 0;
        for (var k = 0; k < length; k++) {
            this.allPoints[this.allPoints.length] = points['textOptions'][k];
            this.connectorFlag = false;
            this.compareDataLabels(k, points, count, seriesIndex);
            this.labelOptions[seriesIndex]['textOptions'][k] = points['textOptions'][k];
            this.labelOptions[seriesIndex]['textOptions'][k].connectorFlag = this.connectorFlag;
        }
    };
    DataLabel.prototype.compareDataLabels = function (i, points, count, m) {
        var length = this.allPoints.length;
        var padding = 10;
        var collide;
        var currentLabel;
        for (var j = 0; j < length; j++) {
            this.prevLabel = this.allPoints[j];
            currentLabel = this.allPoints[length - 1];
            collide = this.isCollide(this.prevLabel, currentLabel);
            if (collide) {
                this.connectorFlag = true;
                switch (count) {
                    case 0:
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] + (this.prevLabel['width'] / 2 +
                            currentLabel['width'] / 2 + padding);
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 1:
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] + this.prevLabel['width'] / 2 +
                            currentLabel['width'] / 2 + padding;
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        currentLabel['yPosition'] = currentLabel['location'].y + currentLabel['height'] / 2 + padding / 2;
                        currentLabel['y'] = currentLabel['yPosition'] + ((currentLabel['height'] / 2)) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 2:
                        this.resetValues(currentLabel);
                        currentLabel['yPosition'] = currentLabel['location'].y + currentLabel['height'] / 2 + padding / 2;
                        currentLabel['y'] = currentLabel['yPosition'] + (currentLabel['height'] / 2) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 3:
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] - this.prevLabel['width'] / 2
                            - currentLabel['width'] / 2 - padding;
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        currentLabel['yPosition'] = currentLabel['height'] / 2 + currentLabel['location'].y + padding / 2;
                        currentLabel['y'] = currentLabel['yPosition'] + ((currentLabel['height'] / 2)) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 4:
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = (this.prevLabel['xPosition'] - this.prevLabel['width'] / 2 -
                            currentLabel['width'] / 2 - padding);
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 5:
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] - this.prevLabel['width'] / 2 -
                            currentLabel['width'] / 2 - padding;
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        currentLabel['yPosition'] = this.prevLabel['yPosition'] - currentLabel['height'] - padding;
                        currentLabel['y'] = currentLabel['yPosition'] + currentLabel['height'] / 2 + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 6:
                        this.resetValues(currentLabel);
                        currentLabel['yPosition'] = (this.prevLabel['yPos']) - (currentLabel['height'] + padding);
                        currentLabel['y'] = currentLabel['yPosition'] + (currentLabel['height'] / 2) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 7:
                        this.resetValues(currentLabel);
                        currentLabel['xPosition'] = this.prevLabel['xPosition'] + this.prevLabel['width'] / 2 +
                            currentLabel['width'] / 2 + padding;
                        currentLabel['x'] = currentLabel['xPosition'] + padding / 2;
                        currentLabel['yPosition'] = this.prevLabel['yPosition'] - currentLabel['height'] - padding;
                        currentLabel['y'] = currentLabel['yPosition'] + (currentLabel['height'] / 2) + padding / 2;
                        count += 1;
                        this.compareDataLabels(i, points, count, m);
                        break;
                    case 8:
                        count = 0;
                        this.compareDataLabels(i, points, count, m);
                        break;
                }
            }
        }
    };
    DataLabel.prototype.isCollide = function (dataLabel1, dataLabel2) {
        var state = false;
        if (dataLabel1 !== dataLabel2) {
            state = !(((dataLabel1['y'] + dataLabel1['height']) < (dataLabel2['y'])) ||
                (dataLabel1['y'] > (dataLabel2['y'] + dataLabel2['height'])) ||
                ((dataLabel1['x'] + dataLabel1['width'] / 2) < dataLabel2['x'] - dataLabel2['width'] / 2) ||
                (dataLabel1['x'] - dataLabel1['width'] / 2 > (dataLabel2['x'] + dataLabel2['width'] / 2)));
        }
        return state;
    };
    DataLabel.prototype.resetValues = function (currentPoint) {
        currentPoint['xPosition'] = currentPoint['labelOptions']['x'];
        currentPoint['yPosition'] = currentPoint['labelOptions']['y'];
        currentPoint['x'] = currentPoint['labelOptions']['textX'];
        currentPoint['y'] = currentPoint['labelOptions']['textY'];
    };
    DataLabel.prototype.drawConnectorLines = function (smithchart, seriesIndex, index, currentPoint, groupElement) {
        var xPos = currentPoint['xPosition'];
        var yPos = currentPoint['yPosition'];
        var location = currentPoint['location'];
        var endY;
        if (location.y > currentPoint['y']) {
            endY = (currentPoint['y']);
        }
        else {
            endY = (currentPoint['y'] - currentPoint['height'] / 2);
        }
        var connectorDirection = 'M' + ' ' + (location.x) + ' ' + (location.y) + ' ' + 'L' + ' ' +
            (currentPoint['x']) + ' ' + (endY);
        var connectorLineValues = smithchart.series[seriesIndex].marker.dataLabel.connectorLine;
        var stroke = connectorLineValues.color ? connectorLineValues.color :
            (smithchart.series[seriesIndex].fill ||
                smithchart.seriesColors[seriesIndex % smithchart.seriesColors.length]);
        var options = new PathOption(smithchart.element.id + '_dataLabelConnectorLine' + '_series' + seriesIndex + '_point' + index, 'none', connectorLineValues.width, stroke, 1, 'none', connectorDirection);
        var element = smithchart.renderer.drawPath(options);
        groupElement.appendChild(element);
    };
    DataLabel.prototype.drawDatalabelSymbol = function (smithchart, seriesindex, dataLabel, groupElement, gdEle, bounds) {
        var labelTemplateElement = createElement('div', {
            id: smithchart.element.id + '_seriesIndex_' + seriesindex + '_Label_Template_Group',
            className: 'template',
            styles: 'position: absolute;'
        });
        document.getElementById(smithchart.element.id + '_Secondary_Element').appendChild(labelTemplateElement);
        for (var i = 0; i < smithchart.series[seriesindex].points.length; i++) {
            if (!dataLabel.template) {
                var options = new DataLabelTextOptions();
                options = this.labelOptions[seriesindex]['textOptions'][i];
                var font = smithchart.font;
                var x = options['xPosition'];
                var y = options['yPosition'];
                var id = smithchart.element.id + '_Series' + seriesindex + '_Points' + i + '_dataLabel' + '_symbol' + i;
                var fill = dataLabel['fill'] ? dataLabel['fill'] : (smithchart.series[seriesindex].fill ||
                    smithchart.seriesColors[seriesindex % smithchart.seriesColors.length]);
                var border = smithchart.series[seriesindex].marker.dataLabel.border;
                var rectOptions = new RectOption(id, fill, border, options['opacity'], new Rect(x, y, options['width'], options['height']));
                var dataEle = smithchart.renderer.drawRectangle(rectOptions);
                gdEle.appendChild(dataEle);
                var textRenderEventArgs = { text: options['text'], x: options['x'], y: options['y'], seriesIndex: seriesindex,
                    pointIndex: i, name: 'textRender', cancel: false };
                smithchart.trigger('textRender', textRenderEventArgs);
                var textoptions = new TextOption(options['id'], textRenderEventArgs.x, textRenderEventArgs.y, 'start', textRenderEventArgs.text);
                var element = renderTextElement(textoptions, font, smithchart.themeStyle.dataLabel, gdEle);
                gdEle.appendChild(element);
            }
            else {
                var templateFn = void 0;
                var labelElement = void 0;
                var id = dataLabel.template + '_seriesIndex' + seriesindex + '_pointIndex' + i + smithchart.element.id;
                var data = { point: smithchart.series[seriesindex].points[i].reactance };
                if (dataLabel.template !== '') {
                    templateFn = getTemplateFunction(dataLabel.template);
                    var templateElement = templateFn(smithchart);
                    labelElement = convertElementFromLabel(templateElement, id, data, seriesindex, smithchart);
                    labelTemplateElement.appendChild(labelElement);
                    labelElement.style.left = this.textOptions[i]['location'].x - labelElement.offsetWidth / 2 + 'px';
                    labelElement.style.top = this.textOptions[i]['location'].y - labelElement.offsetHeight / 2 -
                        smithchart.series[seriesindex].marker.size.height + 'px';
                }
            }
        }
    };
    return DataLabel;
}());
export { DataLabel };
