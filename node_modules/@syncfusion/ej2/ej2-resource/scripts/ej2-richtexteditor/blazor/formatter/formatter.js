var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { extend, isNullOrUndefined, Browser } from '@syncfusion/ej2-base';
import * as eventConstant from '../constant';
import { KEY_DOWN, KEY_UP } from '../../src/common/constant';
import { isIDevice } from '../../src/rich-text-editor/base/util';
import * as CONSTANT from '../../src/rich-text-editor/base/constant';
var Formatter = (function () {
    function Formatter() {
    }
    Formatter.prototype.process = function (self, args, event, value) {
        var _this = this;
        var selection = self.getDocument().getSelection();
        var range = (selection.rangeCount > 0) ? selection.getRangeAt(selection.rangeCount - 1) : null;
        var saveSelection;
        if (self.editorMode === 'HTML') {
            saveSelection = this.editorManager.nodeSelection.save(range, self.getDocument());
        }
        if (!isNullOrUndefined(args)
            && args.item.command
            && args.item.command !== 'Table'
            && args.item.command !== 'Actions'
            && args.item.command !== 'Links'
            && args.item.command !== 'Images'
            && range
            && !(self.getEditPanel().contains(this.getAncestorNode(range.commonAncestorContainer))
                || self.getEditPanel() === range.commonAncestorContainer
                || self.getPanel() === range.commonAncestorContainer)) {
            return;
        }
        if (isNullOrUndefined(args)) {
            var action_1 = event.action;
            if (action_1 !== 'tab' && action_1 !== 'enter' && action_1 !== 'space' && action_1 !== 'escape') {
                args = {};
                if (self.editorMode === 'Markdown' && action_1 === 'insert-table') {
                    value = {
                        'headingText': 'TableHeadingText',
                        'colText': 'TableColText'
                    };
                }
                var items = {
                    originalEvent: event, cancel: false,
                    requestType: action_1 || (event.key + 'Key'),
                };
                extend(args, args, items, true);
                delete args.item;
                args.originalEvent = __assign({}, args.originalEvent, { target: null });
                if (self.actionBeginEnabled) {
                    self.dotNetRef.invokeMethodAsync(eventConstant.actionBeginEvent, args).then(function (actionBeginArgs) {
                        if (args.cancel) {
                            if (action_1 === 'paste' || action_1 === 'cut' || action_1 === 'copy') {
                                event.preventDefault();
                            }
                        }
                    });
                }
            }
            var isTableModule = isNullOrUndefined(self.tableModule) ? true : self.tableModule ?
                self.tableModule.ensureInsideTableList : false;
            if ((event.which === 9 && isTableModule) || event.which !== 9) {
                this.editorManager.observer.notify((event.type === 'keydown' ? KEY_DOWN : KEY_UP), {
                    event: event,
                    callBack: this.onSuccess.bind(this, self),
                    value: value
                });
            }
        }
        else if (!isNullOrUndefined(args) && args.item.command && args.item.subCommand && ((args.item.command !== args.item.subCommand
            && args.item.command !== 'Font')
            || ((args.item.subCommand === 'FontName' || args.item.subCommand === 'FontSize') && args.name === 'dropDownSelect')
            || ((args.item.subCommand === 'BackgroundColor' || args.item.subCommand === 'FontColor')
                && args.name === 'colorPickerChanged'))) {
            args.originalEvent = __assign({}, args.originalEvent, { target: null });
            extend(args, args, { requestType: args.item.subCommand, cancel: false }, true);
            if (self.actionBeginEnabled) {
                self.dotNetRef.invokeMethodAsync(eventConstant.actionBeginEvent, args).then(function (actionBeginArgs) {
                    if (!actionBeginArgs.cancel) {
                        _this.actionBeginCallBack(self, args, saveSelection, event, value);
                    }
                });
            }
            else {
                this.actionBeginCallBack(self, args, saveSelection, event, value);
            }
        }
        if (isNullOrUndefined(event) || event && event.action !== 'copy') {
            this.enableUndo(self);
        }
    };
    Formatter.prototype.getAncestorNode = function (node) {
        node = node.nodeType === 3 ? node.parentNode : node;
        return node;
    };
    Formatter.prototype.onKeyHandler = function (self, e) {
        var _this = this;
        this.editorManager.observer.notify(KEY_UP, {
            event: e, callBack: function () {
                self.observer.notify(CONSTANT.contentChanged, {});
                _this.enableUndo(self);
            }
        });
    };
    Formatter.prototype.onSuccess = function (self, events) {
        var _this = this;
        self.observer.notify(CONSTANT.contentChanged, {});
        if (events && (isNullOrUndefined(events.event) || events.event.action !== 'copy')) {
            this.enableUndo(self);
            self.observer.notify(CONSTANT.execCommandCallBack, events);
        }
        events.event = __assign({}, events.event, { target: null });
        this.successArgs = __assign({}, events);
        delete events.elements;
        delete events.range;
        if (self.actionCompleteEnabled) {
            self.dotNetRef.invokeMethodAsync(eventConstant.actionCompleteEvent, events).then(function (callbackArgs) {
                _this.actionCompleteCallBack(self, callbackArgs);
            });
        }
        else {
            this.actionCompleteCallBack(self, events);
        }
    };
    Formatter.prototype.saveData = function (e) {
        this.editorManager.undoRedoManager.saveData(e);
    };
    Formatter.prototype.getUndoStatus = function () {
        return this.editorManager.undoRedoManager.getUndoStatus();
    };
    Formatter.prototype.getUndoRedoStack = function () {
        return this.editorManager.undoRedoManager.undoRedoStack;
    };
    Formatter.prototype.enableUndo = function (self) {
        if (self.undoRedoStatus) {
            var status_1 = this.getUndoStatus();
            if (self.inlineMode.enable && (!Browser.isDevice || isIDevice())) {
                self.dotNetRef.invokeMethodAsync(eventConstant.updateUndoRedoStatus, status_1);
            }
            else {
                if (self.toolbarModule) {
                    self.dotNetRef.invokeMethodAsync(eventConstant.updateUndoRedoStatus, status_1);
                }
            }
        }
    };
    Formatter.prototype.actionBeginCallBack = function (self, args, selection, event, value) {
        if (this.getUndoRedoStack().length === 0 && args.item.command !== 'Links'
            && args.item.command !== 'Images') {
            this.saveData();
        }
        self.isBlur = false;
        self.getEditPanel().focus();
        if (self.editorMode === 'HTML') {
            selection.restore();
        }
        var command = args.item.subCommand.toLocaleLowerCase();
        if (command === 'paste' || command === 'cut' || command === 'copy') {
            self.clipboardAction(command, event);
        }
        else {
            this.editorManager.observer.notify(CONSTANT.checkUndo, { subCommand: args.item.subCommand });
            this.editorManager.execCommand(args.item.command, args.item.subCommand, event, this.onSuccess.bind(this, self), args.item.value, args.item.subCommand === 'Pre' && args.name === 'dropDownSelect' ?
                { name: args.name } : value, ('#' + '' + ' iframe'));
        }
    };
    Formatter.prototype.actionCompleteCallBack = function (self, args) {
        self.setPlaceHolder();
        if (args.requestType === 'Images' || args.requestType === 'Links' && args.editorMode === 'HTML') {
            var successArgs = this.successArgs;
            if (args.requestType === 'Links' && args.event && args.event.type === 'keydown' &&
                args.event.keyCode === 32) {
                return;
            }
            self.observer.notify(CONSTANT.insertCompleted, {
                args: successArgs.event, type: args.requestType, isNotify: true, elements: successArgs.elements
            });
        }
        self.autoResize();
    };
    return Formatter;
}());
export { Formatter };
