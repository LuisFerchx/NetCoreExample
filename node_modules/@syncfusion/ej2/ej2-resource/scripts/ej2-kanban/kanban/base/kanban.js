var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Component, NotifyPropertyChanges, Property, Complex, Collection, detach } from '@syncfusion/ej2-base';
import { addClass, classList, removeClass, compile, formatUnit, L10n, Browser, Event } from '@syncfusion/ej2-base';
import { createSpinner, hideSpinner, showSpinner } from '@syncfusion/ej2-popups';
import { Data } from './data';
import { SwimlaneSettings } from '../models/swimlane-settings';
import { CardSettings } from '../models/card-settings';
import { DialogSettings } from '../models/dialog-settings';
import { Columns } from '../models/columns';
import { StackedHeaders } from '../models/stacked-headers';
import { SortSettings } from '../models/sort-settings';
import { Action } from '../actions/action';
import { Crud } from '../actions/crud';
import { DragAndDrop } from '../actions/drag';
import { KanbanDialog } from '../actions/dialog';
import { Keyboard } from '../actions/keyboard';
import { KanbanTooltip } from '../actions/tooltip';
import { KanbanTouch } from '../actions/touch';
import { LayoutRender } from './layout-render';
import * as events from '../base/constant';
import * as cls from './css-constant';
var Kanban = (function (_super) {
    __extends(Kanban, _super);
    function Kanban(options, element) {
        return _super.call(this, options, element) || this;
    }
    Kanban.prototype.preRender = function () {
        this.isAdaptive = Browser.isDevice;
        this.kanbanData = [];
        if (!this.enablePersistence || !this.swimlaneToggleArray) {
            this.swimlaneToggleArray = [];
        }
        this.activeCardData = { data: null, element: null };
        var defaultLocale = {
            items: 'items',
            min: 'Min',
            max: 'Max',
            cardsSelected: 'Cards Selected',
            addTitle: 'Add New Card',
            editTitle: 'Edit Card Details',
            deleteTitle: 'Delete Card',
            deleteContent: 'Are you sure you want to delete this card?',
            save: 'Save',
            delete: 'Delete',
            cancel: 'Cancel',
            yes: 'Yes',
            no: 'No',
            close: 'Close',
            noCard: 'No cards to display'
        };
        this.localeObj = new L10n(this.getModuleName(), defaultLocale, this.locale);
        this.scrollPosition = { content: { left: 0, top: 0 }, column: {} };
        this.isInitialRender = true;
    };
    Kanban.prototype.requiredModules = function () {
        var modules = [];
        return modules;
    };
    Kanban.prototype.getPersistData = function () {
        return this.addOnPersist(['columns', 'dataSource', 'swimlaneToggleArray']);
    };
    Kanban.prototype.getModuleName = function () {
        return 'kanban';
    };
    Kanban.prototype.render = function () {
        var addClasses = [cls.ROOT_CLASS];
        var removeClasses = [];
        if (this.enableRtl) {
            addClasses.push(cls.RTL_CLASS);
        }
        else {
            removeClasses.push(cls.RTL_CLASS);
        }
        if (this.isAdaptive) {
            addClasses.push(cls.DEVICE_CLASS);
        }
        else {
            removeClasses.push(cls.DEVICE_CLASS);
        }
        if (this.cssClass) {
            addClasses.push(this.cssClass);
        }
        this.element.setAttribute('role', 'main');
        classList(this.element, addClasses, removeClasses);
        this.element.style.width = formatUnit(this.width);
        this.element.style.height = formatUnit(this.height);
        createSpinner({ target: this.element });
        this.showSpinner();
        this.initializeModules();
    };
    Kanban.prototype.onPropertyChanged = function (newProp, oldProp) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'cssClass':
                    if (oldProp.cssClass) {
                        removeClass([this.element], oldProp.cssClass);
                    }
                    if (newProp.cssClass) {
                        addClass([this.element], newProp.cssClass);
                    }
                    break;
                case 'enableRtl':
                case 'locale':
                    this.refresh();
                    break;
                case 'width':
                    this.element.style.width = formatUnit(newProp.width);
                    this.element.querySelector('.' + cls.HEADER_CLASS).firstElementChild.style.width = 'auto';
                    this.notify(events.contentReady, {});
                    break;
                case 'height':
                    this.element.style.height = formatUnit(newProp.height);
                    this.element.querySelector('.' + cls.CONTENT_CLASS).style.height = 'auto';
                    this.notify(events.contentReady, {});
                    break;
                case 'dataSource':
                case 'query':
                    this.dataModule = new Data(this);
                    break;
                case 'columns':
                case 'constraintType':
                    this.notify(events.dataReady, { processedData: this.kanbanData });
                    break;
                case 'swimlaneSettings':
                    this.onSwimlaneSettingsPropertyChanged(newProp.swimlaneSettings, oldProp.swimlaneSettings);
                    break;
                case 'cardSettings':
                    this.onCardSettingsPropertyChanged(newProp.cardSettings, oldProp.cardSettings);
                    break;
                case 'allowDragAndDrop':
                    if (newProp.allowDragAndDrop) {
                        this.layoutModule.wireDragEvent();
                    }
                    else {
                        this.layoutModule.unWireDragEvent();
                    }
                    break;
                case 'enableTooltip':
                    if (this.tooltipModule) {
                        this.tooltipModule.destroy();
                        this.tooltipModule = null;
                    }
                    if (newProp.enableTooltip) {
                        this.tooltipModule = new KanbanTooltip(this);
                        this.layoutModule.refreshCards();
                    }
                    break;
                case 'dialogSettings':
                    if (newProp.dialogSettings) {
                        this.dialogModule = new KanbanDialog(this);
                    }
                    break;
                case 'allowKeyboard':
                    if (this.keyboardModule) {
                        this.keyboardModule.destroy();
                        this.keyboardModule = null;
                    }
                    if (newProp.allowKeyboard) {
                        this.keyboardModule = new Keyboard(this);
                    }
                    break;
                case 'stackedHeaders':
                    this.layoutModule.refreshHeaders();
                    break;
                case 'sortSettings':
                    this.notify(events.dataReady, { processedData: this.kanbanData });
                    break;
                default:
                    break;
            }
        }
    };
    Kanban.prototype.onSwimlaneSettingsPropertyChanged = function (newProp, _oldProp) {
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'keyField':
                case 'textField':
                case 'showEmptyRow':
                case 'showItemCount':
                case 'template':
                case 'sortDirection':
                    this.notify(events.dataReady, { processedData: this.kanbanData });
                    break;
            }
        }
    };
    Kanban.prototype.onCardSettingsPropertyChanged = function (newProp, _oldProp) {
        var cards = [];
        for (var _i = 0, _a = Object.keys(newProp); _i < _a.length; _i++) {
            var prop = _a[_i];
            switch (prop) {
                case 'showHeader':
                case 'headerField':
                case 'contentField':
                case 'template':
                case 'tagsField':
                case 'grabberField':
                case 'footerCssField':
                    this.layoutModule.refreshCards();
                    break;
                case 'selectionType':
                    cards = this.getSelectedCards();
                    if (cards.length > 0) {
                        removeClass(cards, cls.CARD_SELECTION_CLASS);
                        this.layoutModule.disableAttributeSelection(cards);
                    }
                    break;
            }
        }
    };
    Kanban.prototype.initializeModules = function () {
        this.dataModule = new Data(this);
        this.layoutModule = new LayoutRender(this);
        if (this.allowKeyboard) {
            this.keyboardModule = new Keyboard(this);
        }
        this.actionModule = new Action(this);
        this.crudModule = new Crud(this);
        this.dragAndDropModule = new DragAndDrop(this);
        this.dialogModule = new KanbanDialog(this);
        if (this.enableTooltip) {
            this.tooltipModule = new KanbanTooltip(this);
        }
        if (Browser.isDevice || Browser.isTouch) {
            this.touchModule = new KanbanTouch(this);
        }
    };
    Kanban.prototype.renderTemplates = function () {
        if (this.isReact) {
            this.renderReactTemplates();
        }
    };
    Kanban.prototype.resetTemplates = function (templates) {
        if (this.isReact) {
            this.clearTemplate(templates);
        }
    };
    Kanban.prototype.destroyModules = function () {
        if (this.layoutModule) {
            this.layoutModule.destroy();
            this.layoutModule = null;
        }
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
            this.keyboardModule = null;
        }
        if (this.touchModule) {
            this.touchModule.destroy();
            this.touchModule = null;
        }
        this.dialogModule = null;
        this.actionModule = null;
        this.crudModule = null;
        this.dataModule = null;
        this.dragAndDropModule = null;
    };
    Kanban.prototype.templateParser = function (template) {
        if (template) {
            try {
                if (document.querySelectorAll(template).length) {
                    return compile(document.querySelector(template).innerHTML.trim());
                }
            }
            catch (error) {
                return compile(template);
            }
        }
        return undefined;
    };
    Kanban.prototype.getCardDetails = function (target) {
        var _this = this;
        var isNumeric = typeof (this.kanbanData[0])[this.cardSettings.headerField] === 'number';
        var targetId = isNumeric ? parseInt(target.getAttribute('data-id'), 10) : target.getAttribute('data-id');
        var cardObj = this.kanbanData.filter(function (data) {
            return data[_this.cardSettings.headerField] === targetId;
        })[0];
        return cardObj;
    };
    Kanban.prototype.getColumnData = function (columnKey, dataSource) {
        return this.layoutModule.getColumnCards(dataSource)[columnKey] || [];
    };
    Kanban.prototype.getSwimlaneData = function (keyField) {
        return this.layoutModule.getSwimlaneCards()[keyField] || [];
    };
    Kanban.prototype.getSelectedCards = function () {
        return [].slice.call(this.element.querySelectorAll('.' + cls.CARD_CLASS + '.' + cls.CARD_SELECTION_CLASS));
    };
    Kanban.prototype.showSpinner = function () {
        showSpinner(this.element);
    };
    Kanban.prototype.hideSpinner = function () {
        hideSpinner(this.element);
    };
    Kanban.prototype.openDialog = function (action, data) {
        this.dialogModule.openDialog(action, data);
    };
    Kanban.prototype.closeDialog = function () {
        this.dialogModule.closeDialog();
    };
    Kanban.prototype.addCard = function (cardData, index) {
        this.crudModule.addCard(cardData, index);
    };
    Kanban.prototype.updateCard = function (cardData, index) {
        this.crudModule.updateCard(cardData, index);
    };
    Kanban.prototype.deleteCard = function (cardData) {
        this.crudModule.deleteCard(cardData);
    };
    Kanban.prototype.addColumn = function (columnOptions, index) {
        this.actionModule.addColumn(columnOptions, index);
    };
    Kanban.prototype.deleteColumn = function (index) {
        this.actionModule.deleteColumn(index);
    };
    Kanban.prototype.showColumn = function (key) {
        this.actionModule.showColumn(key);
    };
    Kanban.prototype.hideColumn = function (key) {
        this.actionModule.hideColumn(key);
    };
    Kanban.prototype.refreshHeader = function () {
        this.resetTemplates(['columnTemplate']);
        if (this.layoutModule) {
            this.layoutModule.refreshHeaders();
        }
        this.renderTemplates();
    };
    Kanban.prototype.destroy = function () {
        this.destroyModules();
        [].slice.call(this.element.childNodes).forEach(function (node) { detach(node); });
        var removeClasses = [cls.ROOT_CLASS];
        if (this.cssClass) {
            removeClasses = removeClasses.concat(this.cssClass.split(' '));
        }
        removeClass([this.element], removeClasses);
        _super.prototype.destroy.call(this);
    };
    __decorate([
        Property()
    ], Kanban.prototype, "cssClass", void 0);
    __decorate([
        Property('auto')
    ], Kanban.prototype, "width", void 0);
    __decorate([
        Property('auto')
    ], Kanban.prototype, "height", void 0);
    __decorate([
        Property([])
    ], Kanban.prototype, "dataSource", void 0);
    __decorate([
        Property()
    ], Kanban.prototype, "query", void 0);
    __decorate([
        Property()
    ], Kanban.prototype, "keyField", void 0);
    __decorate([
        Property('Column')
    ], Kanban.prototype, "constraintType", void 0);
    __decorate([
        Property([])
    ], Kanban.prototype, "externalDropId", void 0);
    __decorate([
        Collection([], Columns)
    ], Kanban.prototype, "columns", void 0);
    __decorate([
        Property(true)
    ], Kanban.prototype, "allowKeyboard", void 0);
    __decorate([
        Collection([], StackedHeaders)
    ], Kanban.prototype, "stackedHeaders", void 0);
    __decorate([
        Complex({}, SwimlaneSettings)
    ], Kanban.prototype, "swimlaneSettings", void 0);
    __decorate([
        Complex({}, CardSettings)
    ], Kanban.prototype, "cardSettings", void 0);
    __decorate([
        Complex({}, SortSettings)
    ], Kanban.prototype, "sortSettings", void 0);
    __decorate([
        Complex({}, DialogSettings)
    ], Kanban.prototype, "dialogSettings", void 0);
    __decorate([
        Property(true)
    ], Kanban.prototype, "allowDragAndDrop", void 0);
    __decorate([
        Property(false)
    ], Kanban.prototype, "enableTooltip", void 0);
    __decorate([
        Property(false)
    ], Kanban.prototype, "showEmptyColumn", void 0);
    __decorate([
        Property(false)
    ], Kanban.prototype, "enablePersistence", void 0);
    __decorate([
        Property()
    ], Kanban.prototype, "tooltipTemplate", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "actionBegin", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "actionComplete", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "actionFailure", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "created", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "dataBinding", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "dataBound", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "cardClick", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "cardDoubleClick", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "queryCellInfo", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "cardRendered", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "dragStart", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "drag", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "dragStop", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "dialogOpen", void 0);
    __decorate([
        Event()
    ], Kanban.prototype, "dialogClose", void 0);
    Kanban = __decorate([
        NotifyPropertyChanges
    ], Kanban);
    return Kanban;
}(Component));
export { Kanban };
