import { PdfColorSpace, TextRenderingMode, PdfFillMode, PdfTextAlignment } from './enum';
import { PdfVerticalAlignment, PdfBlendMode } from './enum';
import { PdfSubSuperScript } from './fonts/enum';
import { PdfStreamWriter } from './../input-output/pdf-stream-writer';
import { PdfPen } from './pdf-pen';
import { PdfBrush } from './brushes/pdf-brush';
import { PdfSolidBrush } from './brushes/pdf-solid-brush';
import { PdfFont } from './fonts/pdf-font';
import { PdfTransformationMatrix } from './pdf-transformation-matrix';
import { PointF, SizeF, RectangleF } from './../drawing/pdf-drawing';
import { ProcedureSets } from './constants';
import { PdfString } from './../primitives/pdf-string';
import { PdfStringFormat } from './fonts/pdf-string-format';
import { TemporaryDictionary } from './../collections/object-object-pair/dictionary';
import { PdfTransparency } from './pdf-transparency';
import { PdfStringLayouter, LineType } from './fonts/string-layouter';
import { DictionaryProperties } from './../input-output/pdf-dictionary-properties';
import { StringTokenizer } from './fonts/string-tokenizer';
import { PdfAutomaticFieldInfoCollection } from './../document/automatic-fields/automatic-field-info-collection';
import { PdfAutomaticFieldInfo } from './../document/automatic-fields/automatic-field-info';
import { Operators } from './../input-output/pdf-operators';
import { UnicodeTrueTypeFont } from './fonts/unicode-true-type-font';
import { InternalEnum } from './../primitives/pdf-string';
import { RtlRenderer } from './fonts/rtl-renderer';
import { PdfTextDirection } from './enum';
var PdfGraphics = (function () {
    function PdfGraphics(arg1, arg2, arg3) {
        this.currentColorSpace = PdfColorSpace.Rgb;
        this.previousTextRenderingMode = TextRenderingMode.Fill;
        this.previousCharacterSpacing = 0.0;
        this.previousWordSpacing = 0.0;
        this.previousTextScaling = 100.0;
        this.procedureSets = new ProcedureSets();
        this.isNormalRender = true;
        this.isUseFontSize = false;
        this.isItalic = false;
        this.isEmfTextScaled = false;
        this.isEmf = false;
        this.isEmfPlus = false;
        this.isBaselineFormat = true;
        this.emfScalingFactor = new SizeF(0, 0);
        this.colorSpaceChanged = false;
        this.dictionaryProperties = new DictionaryProperties();
        this.isOverloadWithPosition = false;
        this.isPointOverload = false;
        this.currentColorSpaces = ['RGB', 'CMYK', 'GrayScale', 'Indexed'];
        this.isImageOptimized = false;
        this.graphicsState = [];
        this.istransparencySet = false;
        this.internalAutomaticFields = null;
        this.startCutIndex = -1;
        if (arg3 instanceof PdfStreamWriter) {
            this.pdfStreamWriter = arg3;
            this.getResources = arg2;
            this.canvasSize = arg1;
            this.initialize();
        }
        else {
            this.constructor(arg1, arg2, new PdfStreamWriter(arg3));
        }
    }
    Object.defineProperty(PdfGraphics.prototype, "stringLayoutResult", {
        get: function () {
            return this.pdfStringLayoutResult;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "size", {
        get: function () {
            return this.canvasSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "mediaBoxUpperRightBound", {
        get: function () {
            if (typeof this.internalMediaBoxUpperRightBound === 'undefined') {
                this.internalMediaBoxUpperRightBound = 0;
            }
            return this.internalMediaBoxUpperRightBound;
        },
        set: function (value) {
            this.internalMediaBoxUpperRightBound = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "clientSize", {
        get: function () {
            return new SizeF(this.clipBounds.width, this.clipBounds.height);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "colorSpace", {
        get: function () {
            return this.currentColorSpace;
        },
        set: function (value) {
            this.currentColorSpace = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "streamWriter", {
        get: function () {
            return this.pdfStreamWriter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "matrix", {
        get: function () {
            if (this.transformationMatrix == null) {
                this.transformationMatrix = new PdfTransformationMatrix();
            }
            return this.transformationMatrix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "layer", {
        get: function () {
            return this.pageLayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "page", {
        get: function () {
            return this.pageLayer.page;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphics.prototype, "automaticFields", {
        get: function () {
            if (this.internalAutomaticFields == null || typeof this.internalAutomaticFields === 'undefined') {
                this.internalAutomaticFields = new PdfAutomaticFieldInfoCollection();
            }
            return this.internalAutomaticFields;
        },
        enumerable: true,
        configurable: true
    });
    PdfGraphics.prototype.initialize = function () {
        this.bStateSaved = false;
        this.currentPen = null;
        this.currentBrush = null;
        this.currentFont = null;
        this.currentColorSpace = PdfColorSpace.Rgb;
        this.bCSInitialized = false;
        this.transformationMatrix = null;
        this.previousTextRenderingMode = (-1);
        this.previousCharacterSpacing = -1.0;
        this.previousWordSpacing = -1.0;
        this.previousTextScaling = -100.0;
        this.currentStringFormat = null;
        this.clipBounds = new RectangleF(new PointF(0, 0), this.size);
        this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);
    };
    PdfGraphics.prototype.drawPdfTemplate = function (template, location, size) {
        if (typeof size === 'undefined') {
            if (template == null) {
                throw Error('ArgumentNullException-template');
            }
            this.drawPdfTemplate(template, location, template.size);
        }
        else {
            if (template == null) {
                throw Error('ArgumentNullException-template');
            }
            var scaleX = (template.width > 0) ? size.width / template.width : 1;
            var scaleY = (template.height > 0) ? size.height / template.height : 1;
            var bNeedScale = !(scaleX === 1 && scaleY === 1);
            var state = this.save();
            var matrix = new PdfTransformationMatrix();
            if (this.pageLayer != null) {
                this.getTranslateTransform(location.x, location.y + size.height, matrix);
            }
            if (bNeedScale) {
                this.getScaleTransform(scaleX, scaleY, matrix);
            }
            this.pdfStreamWriter.modifyCtm(matrix);
            var resources = this.getResources.getResources();
            var name_1 = resources.getName(template);
            this.pdfStreamWriter.executeObject(name_1);
            this.restore(state);
            var g = template.graphics;
            if (g != null) {
                for (var index = 0; index < g.automaticFields.automaticFields.length; index++) {
                    var fieldInfo = g.automaticFields.automaticFields[index];
                    var newLocation = new PointF(fieldInfo.location.x + location.x, fieldInfo.location.y + location.y);
                    var scalingX = template.size.width == 0 ? 0 : size.width / template.size.width;
                    var scalingY = template.size.height == 0 ? 0 : size.height / template.size.height;
                    this.automaticFields.add(new PdfAutomaticFieldInfo(fieldInfo.field, newLocation, scalingX, scalingY));
                    this.page.dictionary.modify();
                }
            }
            this.getResources.getResources().requireProcedureSet(this.procedureSets.imageB);
            this.getResources.getResources().requireProcedureSet(this.procedureSets.imageC);
            this.getResources.getResources().requireProcedureSet(this.procedureSets.imageI);
            this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
        }
    };
    PdfGraphics.prototype.drawString = function (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
        if (typeof arg1 === 'string' && arg2 instanceof PdfFont && (arg3 instanceof PdfPen || arg3 === null) && (arg4 instanceof PdfBrush || arg4 === null) && typeof arg5 === 'number' && typeof arg6 === 'number' && (arg7 instanceof PdfStringFormat || arg7 === null) && typeof arg8 === 'undefined') {
            this.isOverloadWithPosition = true;
            this.drawString(arg1, arg2, arg3, arg4, arg5, arg6, (this.clientSize.width - arg5), 0, arg7);
        }
        else {
            var temparg3 = arg3;
            var temparg4 = arg4;
            var temparg5 = arg5;
            var temparg6 = arg6;
            var temparg7 = arg7;
            var temparg8 = arg8;
            var temparg9 = arg9;
            var layouter = new PdfStringLayouter();
            var result = layouter.layout(arg1, arg2, temparg9, new SizeF(temparg7, temparg8), this.isOverloadWithPosition, this.clientSize);
            if (!result.empty) {
                var rect = this.checkCorrectLayoutRectangle(result.actualSize, temparg5, temparg6, temparg9);
                if (temparg7 <= 0) {
                    temparg5 = rect.x;
                    temparg7 = rect.width;
                }
                if (temparg8 <= 0) {
                    temparg6 = rect.y;
                    temparg8 = rect.height;
                }
                this.drawStringLayoutResult(result, arg2, temparg3, temparg4, new RectangleF(temparg5, temparg6, temparg7, temparg8), temparg9);
                this.isEmfTextScaled = false;
                this.emfScalingFactor = new SizeF(0, 0);
            }
            this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
            this.isNormalRender = true;
            this.pdfStringLayoutResult = result;
            this.isUseFontSize = false;
        }
    };
    PdfGraphics.prototype.drawLine = function (arg1, arg2, arg3, arg4, arg5) {
        if (arg2 instanceof PointF) {
            var temparg2 = arg2;
            var temparg3 = arg3;
            this.drawLine(arg1, temparg2.x, temparg2.y, temparg3.x, temparg3.y);
        }
        else {
            var temparg2 = arg2;
            var temparg3 = arg3;
            var temparg4 = arg4;
            var temparg5 = arg5;
            this.stateControl(arg1, null, null);
            var sw = this.streamWriter;
            sw.beginPath(temparg2, temparg3);
            sw.appendLineSegment(temparg4, temparg5);
            sw.strokePath();
            this.getResources.getResources().requireProcedureSet(this.procedureSets.pdf);
        }
    };
    PdfGraphics.prototype.drawRectangle = function (arg1, arg2, arg3, arg4, arg5, arg6) {
        if (arg1 instanceof PdfPen && typeof arg2 === 'number') {
            var temparg3 = arg3;
            this.drawRectangle(arg1, null, arg2, temparg3, arg4, arg5);
        }
        else if (arg1 instanceof PdfBrush && typeof arg2 === 'number') {
            var temparg3 = arg3;
            this.drawRectangle(null, arg1, arg2, temparg3, arg4, arg5);
        }
        else {
            var temparg3 = arg3;
            var temparg4 = arg4;
            var temparg5 = arg5;
            var temparg6 = arg6;
            if (arg2 instanceof PdfSolidBrush && arg2.color.isEmpty) {
                arg2 = null;
            }
            var temparg1 = arg1;
            var temparg2 = arg2;
            this.stateControl(temparg1, temparg2, null);
            this.streamWriter.appendRectangle(temparg3, temparg4, temparg5, temparg6);
            this.drawPath(temparg1, temparg2, false);
        }
    };
    PdfGraphics.prototype.drawPath = function (arg1, arg2, arg3, arg4) {
        if (typeof arg3 === 'boolean') {
            var temparg3 = arg3;
            this.drawPath(arg1, arg2, PdfFillMode.Winding, temparg3);
        }
        else {
            var temparg3 = arg3;
            var temparg4 = arg4;
            var isPen = arg1 != null;
            var isBrush = arg2 != null;
            var isEvenOdd = (temparg3 === PdfFillMode.Alternate);
            if (isPen && isBrush) {
                this.streamWriter.fillStrokePath(isEvenOdd);
            }
            else if (!isPen && !isBrush) {
                this.streamWriter.endPath();
            }
            else if (isPen) {
                this.streamWriter.strokePath();
            }
            else {
                this.streamWriter.fillPath(isEvenOdd);
            }
        }
    };
    PdfGraphics.prototype.drawImage = function (arg1, arg2, arg3, arg4, arg5) {
        if (typeof arg2 === 'number' && typeof arg3 === 'number' && typeof arg4 === 'undefined') {
            var size = arg1.physicalDimension;
            this.drawImage(arg1, arg2, arg3, size.width, size.height);
        }
        else {
            var temparg2 = arg2;
            var temparg3 = arg3;
            var temparg4 = arg4;
            var temparg5 = arg5;
            arg1.save();
            var matrix = new PdfTransformationMatrix();
            this.getTranslateTransform(temparg2, (temparg3 + temparg5), matrix);
            this.getScaleTransform(arg4, arg5, matrix);
            this.pdfStreamWriter.write('q');
            this.pdfStreamWriter.modifyCtm(matrix);
            var resources = this.getResources.getResources();
            if (typeof this.pageLayer !== 'undefined' && this.page != null) {
                resources.document = this.page.document;
            }
            var name_2 = resources.getName(arg1);
            if (typeof this.pageLayer !== 'undefined') {
                this.page.setResources(resources);
            }
            this.pdfStreamWriter.executeObject(name_2);
            this.pdfStreamWriter.write(Operators.restoreState);
            this.pdfStreamWriter.write(Operators.newLine);
            var resource = this.getResources.getResources();
            resource.requireProcedureSet(this.procedureSets.imageB);
            resource.requireProcedureSet(this.procedureSets.imageC);
            resource.requireProcedureSet(this.procedureSets.imageI);
            resource.requireProcedureSet(this.procedureSets.text);
        }
    };
    PdfGraphics.prototype.getLineBounds = function (lineIndex, result, font, layoutRectangle, format) {
        var bounds;
        if (!result.empty && lineIndex < result.lineCount && lineIndex >= 0) {
            var line = result.lines[lineIndex];
            var vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
            var y = vShift + layoutRectangle.y + (result.lineHeight * lineIndex);
            var lineWidth = line.width;
            var hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
            var lineIndent = this.getLineIndent(line, format, layoutRectangle, (lineIndex === 0));
            hShift += (!this.rightToLeft(format)) ? lineIndent : 0;
            var x = layoutRectangle.x + hShift;
            var width = (!this.shouldJustify(line, layoutRectangle.width, format)) ? lineWidth - lineIndent : layoutRectangle.width - lineIndent;
            var height = result.lineHeight;
            bounds = new RectangleF(x, y, width, height);
        }
        else {
            bounds = new RectangleF(0, 0, 0, 0);
        }
        return bounds;
    };
    PdfGraphics.prototype.checkCorrectLayoutRectangle = function (textSize, x, y, format) {
        var layoutedRectangle = new RectangleF(x, y, textSize.width, textSize.width);
        if (format != null) {
            switch (format.alignment) {
                case PdfTextAlignment.Center:
                    layoutedRectangle.x -= layoutedRectangle.width / 2;
                    break;
                case PdfTextAlignment.Right:
                    layoutedRectangle.x -= layoutedRectangle.width;
                    break;
            }
            switch (format.lineAlignment) {
                case PdfVerticalAlignment.Middle:
                    layoutedRectangle.y -= layoutedRectangle.height / 2;
                    break;
                case PdfVerticalAlignment.Bottom:
                    layoutedRectangle.y -= layoutedRectangle.height;
                    break;
            }
        }
        return layoutedRectangle;
    };
    PdfGraphics.prototype.setLayer = function (layer) {
        this.pageLayer = layer;
        var page = layer.page;
        if (page != null && typeof page !== 'undefined') {
            page.beginSave = this.pageSave;
        }
    };
    PdfGraphics.prototype.pageSave = function (page) {
        if (page.graphics.automaticFields != null) {
            for (var i = 0; i < page.graphics.automaticFields.automaticFields.length; i++) {
                var fieldInfo = page.graphics.automaticFields.automaticFields[i];
                fieldInfo.field.performDraw(page.graphics, fieldInfo.location, fieldInfo.scalingX, fieldInfo.scalingY);
            }
        }
    };
    PdfGraphics.prototype.drawStringLayoutResult = function (result, font, pen, brush, layoutRectangle, format) {
        if (!result.empty) {
            this.applyStringSettings(font, pen, brush, format, layoutRectangle);
            var textScaling = (format != null) ? format.horizontalScalingFactor : 100.0;
            if (textScaling !== this.previousTextScaling && !this.isEmfTextScaled) {
                this.pdfStreamWriter.setTextScaling(textScaling);
                this.previousTextScaling = textScaling;
            }
            var height = (format == null || format.lineSpacing === 0) ? font.height : format.lineSpacing + font.height;
            var subScript = (format != null && format.subSuperScript === PdfSubSuperScript.SubScript);
            var shift = 0;
            shift = (subScript) ? height - (font.height + font.metrics.getDescent(format)) : (height - font.metrics.getAscent(format));
            this.shift = shift;
            this.pdfStreamWriter.startNextLine(layoutRectangle.x, layoutRectangle.y - shift);
            this.pdfStreamWriter.setLeading(+height);
            var resultHeight = 0;
            var remainingString = '';
            for (var i = 0; i < result.lines.length; i++) {
                resultHeight += result.lineHeight;
                if ((layoutRectangle.y + resultHeight) > this.clientSize.height) {
                    this.startCutIndex = i;
                    break;
                }
            }
            for (var j = this.startCutIndex; (j < result.lines.length && j >= 0); j++) {
                remainingString += result.lines[j].text;
            }
            var bounds = new RectangleF(layoutRectangle.x, layoutRectangle.y, layoutRectangle.width, layoutRectangle.height);
            this.drawLayoutResult(result, font, format, layoutRectangle);
            this.underlineStrikeoutText(pen, brush, result, font, bounds, format);
            this.isEmfPlus = false;
            this.isUseFontSize = false;
            if (this.startCutIndex !== -1) {
                var page = this.getNextPage();
                page.graphics.drawString(remainingString, font, pen, brush, layoutRectangle.x, 0, layoutRectangle.width, 0, format);
            }
        }
        else {
            throw new Error('ArgumentNullException:result');
        }
    };
    PdfGraphics.prototype.getNextPage = function () {
        var section = this.currentPage.section;
        var nextPage = null;
        var index = section.indexOf(this.currentPage);
        if (index === section.count - 1) {
            nextPage = section.add();
        }
        else {
            nextPage = section.getPages()[index + 1];
        }
        return nextPage;
    };
    PdfGraphics.prototype.setClip = function (rectangle, mode) {
        if (typeof mode === 'undefined') {
            this.setClip(rectangle, PdfFillMode.Winding);
        }
        else {
            this.pdfStreamWriter.appendRectangle(rectangle);
            this.pdfStreamWriter.clipPath((mode === PdfFillMode.Alternate));
        }
    };
    PdfGraphics.prototype.applyStringSettings = function (font, pen, brush, format, bounds) {
        var setLineWidth = false;
        var tm = this.getTextRenderingMode(pen, brush, format);
        this.stateControl(pen, brush, font, format);
        this.pdfStreamWriter.beginText();
        if ((tm) !== this.previousTextRenderingMode) {
            this.pdfStreamWriter.setTextRenderingMode(tm);
            this.previousTextRenderingMode = tm;
        }
        var cs = (format != null) ? format.characterSpacing : 0;
        if (cs !== this.previousCharacterSpacing && !this.isEmfTextScaled) {
            this.pdfStreamWriter.setCharacterSpacing(cs);
            this.previousCharacterSpacing = cs;
        }
        var ws = (format != null) ? format.wordSpacing : 0;
        if (ws !== this.previousWordSpacing) {
            this.pdfStreamWriter.setWordSpacing(ws);
            this.previousWordSpacing = ws;
        }
    };
    PdfGraphics.prototype.getTextVerticalAlignShift = function (textHeight, boundsHeight, format) {
        var shift = 0;
        if (boundsHeight >= 0 && format != null && format.lineAlignment !== PdfVerticalAlignment.Top) {
            switch (format.lineAlignment) {
                case PdfVerticalAlignment.Middle:
                    shift = (boundsHeight - textHeight) / 2;
                    break;
                case PdfVerticalAlignment.Bottom:
                    shift = boundsHeight - textHeight;
                    break;
            }
        }
        return shift;
    };
    PdfGraphics.prototype.drawLayoutResult = function (result, font, format, layoutRectangle) {
        var vAlignShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
        if (vAlignShift !== 0) {
            this.pdfStreamWriter.startNextLine(0, vAlignShift);
        }
        var ttfFont = font;
        var unicode = (ttfFont != null && ttfFont.isUnicode);
        var embed = (ttfFont != null && ttfFont.isEmbedFont);
        var lines = result.lines;
        for (var i = 0, len = lines.length; (i < len && i !== this.startCutIndex); i++) {
            var lineInfo = lines[i];
            var line = lineInfo.text;
            var lineWidth = lineInfo.width;
            var hAlignShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
            var lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, (i === 0));
            hAlignShift += (!this.rightToLeft(format)) ? lineIndent : 0;
            if (hAlignShift !== 0 && !this.isEmfTextScaled) {
                this.pdfStreamWriter.startNextLine(hAlignShift, 0);
            }
            if (unicode) {
                this.drawUnicodeLine(lineInfo, layoutRectangle, font, format);
            }
            else {
                this.drawAsciiLine(lineInfo, layoutRectangle, font, format);
            }
            if (hAlignShift !== 0 && !this.isEmfTextScaled) {
                this.pdfStreamWriter.startNextLine(-hAlignShift, 0);
            }
            if (this.isOverloadWithPosition && lines.length > 1) {
                this.pdfStreamWriter.startNextLine(-(layoutRectangle.x), 0);
                layoutRectangle.x = 0;
                layoutRectangle.width = this.clientSize.width;
                this.isOverloadWithPosition = false;
                this.isPointOverload = true;
            }
        }
        this.getResources.getResources().requireProcedureSet(this.procedureSets.text);
        if (vAlignShift !== 0) {
            this.pdfStreamWriter.startNextLine(0, -(vAlignShift - result.lineHeight));
        }
        this.pdfStreamWriter.endText();
    };
    PdfGraphics.prototype.drawAsciiLine = function (lineInfo, layoutRectangle, font, format) {
        this.justifyLine(lineInfo, layoutRectangle.width, format);
        var value = '';
        if (lineInfo.text.indexOf('(') !== -1 || lineInfo.text.indexOf(')') !== -1) {
            for (var i = 0; i < lineInfo.text.length; i++) {
                if (lineInfo.text[i] === '(') {
                    value += '\\\(';
                }
                else if (lineInfo.text[i] === ')') {
                    value += '\\\)';
                }
                else {
                    value += lineInfo.text[i];
                }
            }
        }
        if (value === '') {
            value = lineInfo.text;
        }
        var line = '(' + value + ')';
        this.pdfStreamWriter.showNextLineText(new PdfString(line));
    };
    PdfGraphics.prototype.drawUnicodeLine = function (lineInfo, layoutRectangle, font, format) {
        var line = lineInfo.text;
        var lineWidth = lineInfo.width;
        var rtl = (format !== null && format.rightToLeft);
        var useWordSpace = (format !== null && (format.wordSpacing !== 0 || format.alignment === PdfTextAlignment.Justify));
        var ttfFont = font;
        var wordSpacing = this.justifyLine(lineInfo, layoutRectangle.width, format);
        var rtlRender = new RtlRenderer();
        if (rtl || (format !== null && format.textDirection !== PdfTextDirection.None)) {
            var blocks = null;
            var rightAlign = (format !== null && format.alignment === PdfTextAlignment.Right);
            if (format !== null && format.textDirection !== PdfTextDirection.None) {
                blocks = rtlRender.layout(line, ttfFont, (format.textDirection === PdfTextDirection.RightToLeft) ? true : false, useWordSpace, format);
            }
            else {
                blocks = rtlRender.layout(line, ttfFont, rightAlign, useWordSpace, format);
            }
            var words = null;
            if (blocks.length > 1) {
                if (format !== null && format.textDirection !== PdfTextDirection.None) {
                    words = rtlRender.splitLayout(line, ttfFont, (format.textDirection === PdfTextDirection.RightToLeft) ? true : false, useWordSpace, format);
                }
                else {
                    words = rtlRender.splitLayout(line, ttfFont, rightAlign, useWordSpace, format);
                }
            }
            else {
                words = [line];
            }
            this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
        }
        else {
            if (useWordSpace) {
                var result = this.breakUnicodeLine(line, ttfFont, null);
                var blocks = result.tokens;
                var words = result.words;
                this.drawUnicodeBlocks(blocks, words, ttfFont, format, wordSpacing);
            }
            else {
                var token = this.convertToUnicode(line, ttfFont);
                var value = this.getUnicodeString(token);
                this.streamWriter.showNextLineText(value);
            }
        }
    };
    PdfGraphics.prototype.drawUnicodeBlocks = function (blocks, words, font, format, wordSpacing) {
        if (blocks == null) {
            throw new Error('Argument Null Exception : blocks');
        }
        if (words == null) {
            throw new Error('Argument Null Exception : words');
        }
        if (font == null) {
            throw new Error('Argument Null Exception : font');
        }
        this.streamWriter.startNextLine();
        var x = 0;
        var xShift = 0;
        var firstLineIndent = 0;
        var paragraphIndent = 0;
        try {
            if (format !== null) {
                firstLineIndent = format.firstLineIndent;
                paragraphIndent = format.paragraphIndent;
                format.firstLineIndent = 0;
                format.paragraphIndent = 0;
            }
            var spaceWidth = font.getCharWidth(StringTokenizer.whiteSpace, format) + wordSpacing;
            var characterSpacing = (format != null) ? format.characterSpacing : 0;
            var wordSpace = (format !== null && wordSpacing === 0) ? format.wordSpacing : 0;
            spaceWidth += characterSpacing + wordSpace;
            for (var i = 0; i < blocks.length; i++) {
                var token = blocks[i];
                var word = words[i];
                var tokenWidth = 0;
                if (x !== 0) {
                    this.streamWriter.startNextLine(x, 0);
                }
                if (word.length > 0) {
                    tokenWidth += font.measureString(word, format).width;
                    tokenWidth += characterSpacing;
                    var val = this.getUnicodeString(token);
                    this.streamWriter.showText(val);
                }
                if (i !== blocks.length - 1) {
                    x = tokenWidth + spaceWidth;
                    xShift += x;
                }
            }
            if (xShift > 0) {
                this.streamWriter.startNextLine(-xShift, 0);
            }
        }
        finally {
            if (format !== null) {
                format.firstLineIndent = firstLineIndent;
                format.paragraphIndent = paragraphIndent;
            }
        }
    };
    PdfGraphics.prototype.breakUnicodeLine = function (line, ttfFont, words) {
        if (line === null) {
            throw new Error('Argument Null Exception : line');
        }
        words = line.split(null);
        var tokens = [];
        for (var i = 0; i < words.length; i++) {
            var word = words[i];
            var token = this.convertToUnicode(word, ttfFont);
            tokens[i] = token;
        }
        return { tokens: tokens, words: words };
    };
    PdfGraphics.prototype.getUnicodeString = function (token) {
        if (token === null) {
            throw new Error('Argument Null Exception : token');
        }
        var val = new PdfString(token);
        val.converted = true;
        val.encode = InternalEnum.ForceEncoding.Ascii;
        return val;
    };
    PdfGraphics.prototype.convertToUnicode = function (text, ttfFont) {
        var token = null;
        if (text == null) {
            throw new Error('Argument Null Exception : text');
        }
        if (ttfFont == null) {
            throw new Error('Argument Null Exception : ttfFont');
        }
        if (ttfFont.fontInternal instanceof UnicodeTrueTypeFont) {
            var ttfReader = ttfFont.fontInternal.ttfReader;
            ttfFont.setSymbols(text);
            token = ttfReader.convertString(text);
            var bytes = PdfString.toUnicodeArray(token, false);
            token = PdfString.byteToString(bytes);
        }
        return token;
    };
    PdfGraphics.prototype.justifyLine = function (lineInfo, boundsWidth, format) {
        var line = lineInfo.text;
        var lineWidth = lineInfo.width;
        var shouldJustify = this.shouldJustify(lineInfo, boundsWidth, format);
        var hasWordSpacing = (format != null && format.wordSpacing !== 0);
        var symbols = StringTokenizer.spaces;
        var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
        var wordSpace = 0;
        if (shouldJustify) {
            if (hasWordSpacing) {
                lineWidth -= (whitespacesCount * format.wordSpacing);
            }
            var difference = boundsWidth - lineWidth;
            wordSpace = difference / whitespacesCount;
            this.pdfStreamWriter.setWordSpacing(wordSpace);
        }
        else {
            if (hasWordSpacing) {
                this.pdfStreamWriter.setWordSpacing(format.wordSpacing);
            }
            else {
                this.pdfStreamWriter.setWordSpacing(0);
            }
        }
        return wordSpace;
    };
    PdfGraphics.prototype.reset = function (size) {
        this.canvasSize = size;
        this.streamWriter.clear();
        this.initialize();
        this.initializeCoordinates();
    };
    PdfGraphics.prototype.shouldJustify = function (lineInfo, boundsWidth, format) {
        var line = lineInfo.text;
        var lineWidth = lineInfo.width;
        var justifyStyle = (format != null && format.alignment === PdfTextAlignment.Justify);
        var goodWidth = (boundsWidth >= 0 && lineWidth < boundsWidth);
        var symbols = StringTokenizer.spaces;
        var whitespacesCount = StringTokenizer.getCharsCount(line, symbols);
        var hasSpaces = (whitespacesCount > 0 && line[0] !== StringTokenizer.whiteSpace);
        var goodLineBreakStyle = ((lineInfo.lineType & LineType.LayoutBreak) > 0);
        var shouldJustify = (justifyStyle && goodWidth && hasSpaces && (goodLineBreakStyle || format.alignment === PdfTextAlignment.Justify));
        return shouldJustify;
    };
    PdfGraphics.prototype.underlineStrikeoutText = function (pen, brush, result, font, layoutRectangle, format) {
        if (font.underline || font.strikeout) {
            var linePen = this.createUnderlineStikeoutPen(pen, brush, font, format);
            if (linePen != null) {
                var vShift = this.getTextVerticalAlignShift(result.actualSize.height, layoutRectangle.height, format);
                var underlineYOffset = 0;
                underlineYOffset = layoutRectangle.y + vShift + font.metrics.getAscent(format) + 1.5 * linePen.width;
                var strikeoutYOffset = layoutRectangle.y + vShift + font.metrics.getHeight(format) / 2 + 1.5 * linePen.width;
                var lines = result.lines;
                for (var i = 0, len = result.lineCount; i < len; i++) {
                    var lineInfo = lines[i];
                    var line = lineInfo.text;
                    var lineWidth = lineInfo.width;
                    var hShift = this.getHorizontalAlignShift(lineWidth, layoutRectangle.width, format);
                    var lineIndent = this.getLineIndent(lineInfo, format, layoutRectangle, (i === 0));
                    hShift += (!this.rightToLeft(format)) ? lineIndent : 0;
                    var x1 = layoutRectangle.x + hShift;
                    var x2 = (!this.shouldJustify(lineInfo, layoutRectangle.width, format)) ? x1 + lineWidth - lineIndent : x1 + layoutRectangle.width - lineIndent;
                    if (font.underline) {
                        var y = underlineYOffset;
                        this.drawLine(linePen, x1, y, x2, y);
                        underlineYOffset += result.lineHeight;
                    }
                    if (font.strikeout) {
                        var y = strikeoutYOffset;
                        this.drawLine(linePen, x1, y, x2, y);
                        strikeoutYOffset += result.lineHeight;
                    }
                    if (this.isPointOverload && lines.length > 1) {
                        layoutRectangle.x = 0;
                        layoutRectangle.width = this.clientSize.width;
                    }
                }
                this.isPointOverload = false;
            }
        }
    };
    PdfGraphics.prototype.createUnderlineStikeoutPen = function (pen, brush, font, format) {
        var lineWidth = font.metrics.getSize(format) / 20;
        var linePen = null;
        if (pen != null) {
            linePen = new PdfPen(pen.color, lineWidth);
        }
        else if (brush != null) {
            linePen = new PdfPen(brush, lineWidth);
        }
        return linePen;
    };
    PdfGraphics.prototype.getTextRenderingMode = function (pen, brush, format) {
        var tm = TextRenderingMode.None;
        if (pen != null && brush != null) {
            tm = TextRenderingMode.FillStroke;
        }
        else if (pen != null) {
            tm = TextRenderingMode.Stroke;
        }
        else {
            tm = TextRenderingMode.Fill;
        }
        if (format != null && format.clipPath) {
            tm |= TextRenderingMode.ClipFlag;
        }
        return tm;
    };
    PdfGraphics.prototype.getLineIndent = function (lineInfo, format, layoutBounds, firstLine) {
        var lineIndent = 0;
        var firstParagraphLine = ((lineInfo.lineType & LineType.FirstParagraphLine) > 0);
        if (format != null && firstParagraphLine) {
            lineIndent = (firstLine) ? format.firstLineIndent : format.paragraphIndent;
            lineIndent = (layoutBounds.width > 0) ? Math.min(layoutBounds.width, lineIndent) : lineIndent;
        }
        return lineIndent;
    };
    PdfGraphics.prototype.getHorizontalAlignShift = function (lineWidth, boundsWidth, format) {
        var shift = 0;
        if (boundsWidth >= 0 && format != null && format.alignment !== PdfTextAlignment.Left) {
            switch (format.alignment) {
                case PdfTextAlignment.Center:
                    shift = (boundsWidth - lineWidth) / 2;
                    break;
                case PdfTextAlignment.Right:
                    shift = boundsWidth - lineWidth;
                    break;
            }
        }
        return shift;
    };
    PdfGraphics.prototype.rightToLeft = function (format) {
        var rtl = (format != null && format.rightToLeft);
        if (format !== null && typeof format !== 'undefined') {
            if (format.textDirection !== PdfTextDirection.None && typeof format.textDirection !== 'undefined') {
                rtl = true;
            }
        }
        return rtl;
    };
    PdfGraphics.prototype.stateControl = function (pen, brush, font, format) {
        if (typeof format === 'undefined') {
            this.stateControl(pen, brush, font, null);
        }
        else {
            var saveState = false;
            if (brush !== null) {
                var solidBrush = brush;
                if (typeof this.pageLayer !== 'undefined' && this.pageLayer != null) {
                    if (this.colorSpaceChanged === false) {
                        this.lastDocumentCS = this.pageLayer.page.document.colorSpace;
                        this.lastGraphicsCS = this.pageLayer.page.graphics.colorSpace;
                        this.colorSpace = this.pageLayer.page.document.colorSpace;
                        this.currentColorSpace = this.pageLayer.page.document.colorSpace;
                        this.colorSpaceChanged = true;
                    }
                }
                this.initCurrentColorSpace(this.currentColorSpace);
            }
            else if (pen != null) {
                var pdfPen = pen;
                if (typeof this.pageLayer !== 'undefined' && this.pageLayer != null) {
                    this.colorSpace = this.pageLayer.page.document.colorSpace;
                    this.currentColorSpace = this.pageLayer.page.document.colorSpace;
                }
                this.initCurrentColorSpace(this.currentColorSpace);
            }
            this.penControl(pen, saveState);
            this.brushControl(brush, saveState);
            this.fontControl(font, format, saveState);
        }
    };
    PdfGraphics.prototype.initCurrentColorSpace = function (colorspace) {
        var re = this.getResources.getResources();
        if (!this.bCSInitialized) {
            this.pdfStreamWriter.setColorSpace('Device' + this.currentColorSpaces[this.currentColorSpace], true);
            this.pdfStreamWriter.setColorSpace('Device' + this.currentColorSpaces[this.currentColorSpace], false);
            this.bCSInitialized = true;
        }
    };
    PdfGraphics.prototype.penControl = function (pen, saveState) {
        if (pen != null) {
            this.currentPen = pen;
            this.colorSpace = PdfColorSpace.Rgb;
            pen.monitorChanges(this.currentPen, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace, this.matrix.clone());
            this.currentPen = pen.clone();
        }
    };
    PdfGraphics.prototype.brushControl = function (brush, saveState) {
        if (brush != null) {
            this.currentBrush = brush;
            brush.monitorChanges(this.currentBrush, this.pdfStreamWriter, this.getResources, saveState, this.colorSpace);
            this.currentBrush = brush;
            brush = null;
        }
    };
    PdfGraphics.prototype.fontControl = function (font, format, saveState) {
        if (font != null) {
            var curSubSuper = (format != null) ? format.subSuperScript : PdfSubSuperScript.None;
            var prevSubSuper = (this.currentStringFormat != null) ? this.currentStringFormat.subSuperScript : PdfSubSuperScript.None;
            if (saveState || font !== this.currentFont || curSubSuper !== prevSubSuper) {
                var resources = this.getResources.getResources();
                this.currentFont = font;
                this.currentStringFormat = format;
                var size = font.metrics.getSize(format);
                this.isEmfTextScaled = false;
                var fontName = resources.getName(font);
                this.pdfStreamWriter.setFont(font, fontName, size);
            }
        }
    };
    PdfGraphics.prototype.setTransparency = function (arg1, arg2, arg3) {
        if (typeof arg2 === 'undefined') {
            this.istransparencySet = true;
            this.setTransparency(arg1, arg1, PdfBlendMode.Normal);
        }
        else if (typeof arg2 === 'number' && typeof arg3 === 'undefined') {
            this.setTransparency(arg1, arg2, PdfBlendMode.Normal);
        }
        else {
            if (this.trasparencies == null) {
                this.trasparencies = new TemporaryDictionary();
            }
            var transp = null;
            var td = new TransparencyData(arg1, arg2, arg3);
            if (this.trasparencies.containsKey(td)) {
                transp = this.trasparencies.getValue(td);
            }
            if (transp == null) {
                transp = new PdfTransparency(arg1, arg2, arg3);
                this.trasparencies.setValue(td, transp);
            }
            var resources = this.getResources.getResources();
            var name_3 = resources.getName(transp);
            var sw = this.streamWriter;
            sw.setGraphicsState(name_3);
        }
    };
    PdfGraphics.prototype.clipTranslateMargins = function (x, y, left, top, right, bottom) {
        if (x instanceof RectangleF && typeof y === 'undefined') {
            this.clipBounds = x;
            this.pdfStreamWriter.writeComment('Clip margins.');
            this.pdfStreamWriter.appendRectangle(x);
            this.pdfStreamWriter.closePath();
            this.pdfStreamWriter.clipPath(false);
            this.pdfStreamWriter.writeComment('Translate co-ordinate system.');
            this.translateTransform(x.x, x.y);
        }
        else if (typeof x === 'number') {
            var clipArea = new RectangleF(left, top, this.size.width - left - right, this.size.height - top - bottom);
            this.clipBounds = clipArea;
            this.pdfStreamWriter.writeComment("Clip margins.");
            this.pdfStreamWriter.appendRectangle(clipArea);
            this.pdfStreamWriter.closePath();
            this.pdfStreamWriter.clipPath(false);
            this.pdfStreamWriter.writeComment("Translate co-ordinate system.");
            this.translateTransform(x, y);
        }
    };
    PdfGraphics.prototype.updateY = function (y) {
        return -y;
    };
    PdfGraphics.prototype.translateTransform = function (offsetX, offsetY) {
        var matrix = new PdfTransformationMatrix();
        this.getTranslateTransform(offsetX, offsetY, matrix);
        this.pdfStreamWriter.modifyCtm(matrix);
        this.matrix.multiply(matrix);
    };
    PdfGraphics.prototype.getTranslateTransform = function (x, y, input) {
        input.translate(x, this.updateY(y));
        return input;
    };
    PdfGraphics.prototype.scaleTransform = function (scaleX, scaleY) {
        var matrix = new PdfTransformationMatrix();
        this.getScaleTransform(scaleX, scaleY, matrix);
        this.pdfStreamWriter.modifyCtm(matrix);
        this.matrix.multiply(matrix);
    };
    PdfGraphics.prototype.getScaleTransform = function (x, y, input) {
        if (input == null) {
            input = new PdfTransformationMatrix();
        }
        input.scale(x, y);
        return input;
    };
    PdfGraphics.prototype.rotateTransform = function (angle) {
        var matrix = new PdfTransformationMatrix();
        this.getRotateTransform(angle, matrix);
        this.pdfStreamWriter.modifyCtm(matrix);
        this.matrix.multiply(matrix);
    };
    PdfGraphics.prototype.initializeCoordinates = function () {
        this.pdfStreamWriter.writeComment('Change co-ordinate system to left/top.');
        if (this.mediaBoxUpperRightBound !== -(this.size.height)) {
            if (this.cropBox == null) {
                if (this.mediaBoxUpperRightBound === this.size.height || this.mediaBoxUpperRightBound === 0) {
                    this.translateTransform(0, this.updateY(this.size.height));
                }
                else {
                    this.translateTransform(0, this.updateY(this.mediaBoxUpperRightBound));
                }
            }
        }
    };
    PdfGraphics.prototype.getRotateTransform = function (angle, input) {
        if (input == null || typeof input === 'undefined') {
            input = new PdfTransformationMatrix();
        }
        input.rotate(this.updateY(angle));
        return input;
    };
    PdfGraphics.prototype.save = function () {
        var state = new PdfGraphicsState(this, this.matrix.clone());
        state.brush = this.currentBrush;
        state.pen = this.currentPen;
        state.font = this.currentFont;
        state.colorSpace = this.currentColorSpace;
        state.characterSpacing = this.previousCharacterSpacing;
        state.wordSpacing = this.previousWordSpacing;
        state.textScaling = this.previousTextScaling;
        state.textRenderingMode = this.previousTextRenderingMode;
        this.graphicsState.push(state);
        this.pdfStreamWriter.saveGraphicsState();
        return state;
    };
    PdfGraphics.prototype.restore = function (state) {
        if (typeof state === 'undefined') {
            if (this.graphicsState.length > 0) {
                this.doRestoreState();
            }
        }
        else {
            if (this.graphicsState.indexOf(state) !== -1) {
                for (;;) {
                    if (this.graphicsState.length === 0) {
                        break;
                    }
                    var popState = this.doRestoreState();
                    if (popState === state) {
                        break;
                    }
                }
            }
        }
    };
    PdfGraphics.prototype.doRestoreState = function () {
        var state = this.graphicsState.pop();
        this.transformationMatrix = state.matrix;
        this.currentBrush = state.brush;
        this.currentPen = state.pen;
        this.currentFont = state.font;
        this.currentColorSpace = state.colorSpace;
        this.previousCharacterSpacing = state.characterSpacing;
        this.previousWordSpacing = state.wordSpacing;
        this.previousTextScaling = state.textScaling;
        this.previousTextRenderingMode = state.textRenderingMode;
        this.pdfStreamWriter.restoreGraphicsState();
        return state;
    };
    PdfGraphics.pathTypesValuesMask = 0xf;
    PdfGraphics.transparencyObject = false;
    return PdfGraphics;
}());
export { PdfGraphics };
var GetResourceEventHandler = (function () {
    function GetResourceEventHandler(sender) {
        this.sender = sender;
    }
    GetResourceEventHandler.prototype.getResources = function () {
        return this.sender.getResources();
    };
    return GetResourceEventHandler;
}());
export { GetResourceEventHandler };
var PdfGraphicsState = (function () {
    function PdfGraphicsState(graphics, matrix) {
        this.internalTextRenderingMode = TextRenderingMode.Fill;
        this.internalCharacterSpacing = 0.0;
        this.internalWordSpacing = 0.0;
        this.internalTextScaling = 100.0;
        this.pdfColorSpace = PdfColorSpace.Rgb;
        if (typeof graphics !== 'undefined') {
            this.pdfGraphics = graphics;
            this.transformationMatrix = matrix;
        }
    }
    Object.defineProperty(PdfGraphicsState.prototype, "graphics", {
        get: function () {
            return this.pdfGraphics;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "matrix", {
        get: function () {
            return this.transformationMatrix;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "characterSpacing", {
        get: function () {
            return this.internalCharacterSpacing;
        },
        set: function (value) {
            this.internalCharacterSpacing = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "wordSpacing", {
        get: function () {
            return this.internalWordSpacing;
        },
        set: function (value) {
            this.internalWordSpacing = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "textScaling", {
        get: function () {
            return this.internalTextScaling;
        },
        set: function (value) {
            this.internalTextScaling = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "pen", {
        get: function () {
            return this.pdfPen;
        },
        set: function (value) {
            this.pdfPen = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "brush", {
        get: function () {
            return this.pdfBrush;
        },
        set: function (value) {
            this.pdfBrush = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "font", {
        get: function () {
            return this.pdfFont;
        },
        set: function (value) {
            this.pdfFont = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "colorSpace", {
        get: function () {
            return this.pdfColorSpace;
        },
        set: function (value) {
            this.pdfColorSpace = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGraphicsState.prototype, "textRenderingMode", {
        get: function () {
            return this.internalTextRenderingMode;
        },
        set: function (value) {
            this.internalTextRenderingMode = value;
        },
        enumerable: true,
        configurable: true
    });
    return PdfGraphicsState;
}());
export { PdfGraphicsState };
var TransparencyData = (function () {
    function TransparencyData(alphaPen, alphaBrush, blendMode) {
        this.alphaPen = alphaPen;
        this.alphaBrush = alphaBrush;
        this.blendMode = blendMode;
    }
    return TransparencyData;
}());
